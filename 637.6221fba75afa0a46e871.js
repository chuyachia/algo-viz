(self.webpackChunkalgo_viz=self.webpackChunkalgo_viz||[]).push([[637,72,294,701,231,235],{72:(e,t,i)=>{"use strict";i.r(t),i.d(t,{Edge:()=>s});var o=i(314);function s(e,t,i,s,n){this.weight=e,this.from=t,this.to=i;let r=o.s7.r,l=o.s7.b,d=o.s7.g;this.display=function(){if(null!=this.from&&null!=this.to){var e=n.atan2(this.from.y-this.to.y,this.from.x-this.to.x);n.push(),n.stroke(r,d,l),n.strokeWeight(this.weight),n.line(this.from.x,this.from.y,this.to.x+s*n.cos(e),this.to.y+s*n.sin(e)),n.pop(),n.push(),n.translate(this.to.x,this.to.y),n.rotate(e-n.HALF_PI),n.stroke(r,d,l),n.fill(n.color(255,255,255)),n.triangle(0,s/2,s/4,s,-s/4,s),n.pop()}},this.changeColor=function(e){r=e.r,d=e.g,l=e.b}}},294:(e,t,i)=>{"use strict";i.r(t),i.d(t,{drawVertices:()=>s,getClosestVertex:()=>n});var o=i(231);function s(e,t,i,s,n,r,l){const d=[];let c=e.TWO_PI/t,h=0;for(let a=0;a<t;a++){let t=n*e.cos(h)+i/2,g=n*e.sin(h)+s/2;d.push(new o.Vertex(a,t,g,r,e,l)),h+=c}return d}function n(e,t){for(const i of t)if(e.dist(e.mouseX,e.mouseY,i.x,i.y)<20)return i}},701:(e,t,i)=>{"use strict";i.r(t),i.d(t,{GrowingEdge:()=>s});var o=i(314);function s(e,t,i){this.weight=1,this.increaseWeight=function(){this.weight+=1/i.deltaTime,this.weight=this.weight%10},this.display=function(){i.push(),i.stroke(o.s7.r,o.s7.g,o.s7.b),i.strokeWeight(this.weight),i.line(e,t,i.mouseX,i.mouseY),i.pop()}}},231:(e,t,i)=>{"use strict";i.r(t),i.d(t,{Vertex:()=>n});var o=i(314),s=i(72);function n(e,t,i,n,r,l){this.id=e,this.x=t,this.y=i,this.edges={},this.value,this.displayValue=l;let d=o.s7.r,c=o.s7.b,h=o.s7.g;this.display=function(){r.push(),r.strokeWeight(0),r.fill(r.color(d,c,h)),r.circle(this.x,this.y,n),r.fill(r.color(0,0,0)),r.textAlign(r.CENTER),r.text(this.id+" : "+this.displayValue,this.x,this.y+n),r.pop();for(const[e,t]of Object.entries(this.edges))t.display()},this.changeColor=function(e){d=e.r,h=e.g,c=e.b},this.getColor=function(){return{r:d,g:h,b:c}},this.addEdge=function(e,t){e.id!=this.id&&(this.edges[e.id]=new s.Edge(t,this,e,n,r))}}},637:(e,t,i)=>{"use strict";i.r(t),i.d(t,{sketch:()=>l,explainText:()=>d});var o=i(314),s=i(294),n=i(701),r=i(235);function l(e){const t=30;let i,l,d,c,h=[],a=0,g=[];e.setup=function(){e.createCanvas(550,550),d=e.createButton(""),d.position(10,40),h=(0,s.drawVertices)(e,20,550,550,200,t,"?")},e.draw=function(){if(e.background(255,255,255),function(){switch(a){case 0:e.text("Click on nodes to add link.\nOnce the graph is done, click on the button to find topological ordering of the nodes",10,10),d.html("Find topological ordering"),d.show(),d.mousePressed((function(){a=1,c=(0,r.topologicalSort)(h)}));break;case 1:e.text("Finding topological ordering",10,10),d.hide();break;case 2:0==g.length?e.text("Graph contains cycle. Topological ordering does not exist",10,10):e.text("Topological ordering found",10,10),d.show(),d.html("Restart"),d.mousePressed((function(){h=[],c=void 0,a=0,h=(0,s.drawVertices)(e,20,550,550,200,t,"?")}))}}(),e.push(),e.strokeWeight(0),e.fill(e.color(o.s7.r,o.s7.b,o.s7.g)),e.circle(t,520,t),e.textAlign(e.LEFT),e.text("ID : order",60,520),e.fill(e.color(o.hM.r,o.hM.b,o.hM.g)),e.circle(t,490,t),e.text("Visiting",60,490),e.fill(e.color(o.Ej.r,o.Ej.b,o.Ej.g)),e.circle(t,460,t),e.text("Visited",60,460),e.pop(),0==a)void 0!==i&&i.display();else if(1==a){let e=c.next();e.done?a=2:g=e.value}for(const e of h)e.display()},e.mouseReleased=function(){if(a>0)return;const t=(0,s.getClosestVertex)(e,h);void 0!==t&&(void 0===l?(l=t,i=new n.GrowingEdge(l.x,l.y,e)):(l.addEdge(t,1),l=void 0,i=void 0))}}const d="<p>Topological ordering of a graph is an ordering of the nodes in the graph following which all of one node's dependencies will visited before itself. The dependencies of a node are the nodes connected to it by incoming edges. Topological ordering does not exist on graphs that contain cycles</p><p>Topological sort algorithm starts at a random node and performs depth first search to visit all its neighbors and their neighbors until no unvisited node can be reached. At this point, the algorithm backtracks and adds nodes to the back of a list of ordered nodes. After backtracking is done, the algorithm pick the next unvisited node and repeat the procedure until all nodes are visited.</p>"},235:(e,t,i)=>{"use strict";i.r(t),i.d(t,{topologicalSort:()=>l});var o=i(314),s=i(155),n=i(982),r=i(72);function*l(e){const t=[],i=[];let l=e.length,d=!1,c=(0,n.f)(50);const h=new s.S,a=new s.S;for(let s of e){let e=0;if(d)break;if(2!==t[s.id])for(h.addFirst({seq:e,edge:new r.Edge(0,null,s,0,0)}),a.addFirst({seq:e,edge:new r.Edge(0,null,s,0,0)}),e++;h.size()>0;){let s=h.poll().edge,n=s.to;for(t[n.id]=1,s.changeColor(o.hM),n.changeColor(o.hM);!1===c.next().value;)yield d?[]:i;for(const[i,o]of Object.entries(n.edges)){let i=o.to;if(2!=t[i.id]){if(1==t[i.id]){d=!0;break}h.addFirst({seq:e,edge:o}),a.addFirst({seq:e,edge:o}),e++}}for(;a.size()>0&&(0==h.size()||h.peek().seq!=a.peek().seq);){let{edge:e}=a.poll(),s=e.to;for(t[s.id]=2,e.changeColor(o.s7),s.changeColor(o.Ej),s.displayValue=null==(g=l)?"NA":1==g?g+"st":2==g?g+"nd":3==g?g+"rd":g+"th",i[--l]=s.id;!1===c.next().value;)yield d?[]:i}}}var g}},314:(e,t,i)=>{"use strict";i.d(t,{hM:()=>o,Ej:()=>s,s7:()=>n});const o={r:254,g:160,b:144},s={r:89,g:199,b:235},n={r:154,g:160,b:167}},155:(e,t,i)=>{"use strict";function o(){let e,t,i=0;this.addFirst=function(t){let o={value:t};o.next=e,e=o,i++},this.add=function(o){let s={value:o};null==e&&(e=s),null==t?t=s:(t.next=s,t=t.next),i++},this.peek=function(){return null!=e?e.value:void 0},this.poll=function(){const t=e;return e=e.next,i--,t.value},this.size=function(){return i}}i.d(t,{S:()=>o})},982:(e,t,i)=>{"use strict";function*o(e){for(;;){for(let t=0;t<e-1;t++)yield!1;yield!0}}i.d(t,{f:()=>o})}}]);