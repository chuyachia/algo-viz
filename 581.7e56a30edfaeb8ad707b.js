(self.webpackChunkalgo_viz=self.webpackChunkalgo_viz||[]).push([[581,878,401,14,745,175,964,726,252,129],{878:(e,t,i)=>{"use strict";i.r(t),i.d(t,{Edge:()=>o});var n=i(964);function o(e,t,i){this.weight=e,this.from=t,this.to=i;let o=n.GREY.r,s=n.GREY.g,r=n.GREY.b;this.display=function(e,t,i){null!=this.from&&null!=this.to&&(i?this.drawDirectedEdge(e,t):this.drawUndirectedEdge(e,t))},this.drawUndirectedEdge=function(e,t){var i=e.atan2(this.from.y-this.to.y,this.from.x-this.to.x);e.push(),e.stroke(o,s,r),e.strokeWeight(this.weight),e.line(this.from.x,this.from.y,this.to.x+t/2*e.cos(i),this.to.y+t/2*e.sin(i)),e.pop()},this.drawDirectedEdge=function(e,t){var i=e.atan2(this.from.y-this.to.y,this.from.x-this.to.x);e.push(),e.stroke(o,s,r),e.strokeWeight(this.weight),e.line(this.from.x,this.from.y,this.to.x+t*e.cos(i),this.to.y+t*e.sin(i)),e.pop(),e.push(),e.stroke(o,s,r),e.fill(e.color(255,255,255)),e.translate(this.to.x,this.to.y),e.rotate(i-e.HALF_PI),e.triangle(0,t/2,t/4,t,-t/4,t),e.pop()},this.changeColor=function(e){o=e.r,s=e.g,r=e.b}}},401:(e,t,i)=>{"use strict";i.r(t),i.d(t,{drawVertices:()=>o,getClosestVertex:()=>s});var n=i(745);function o(e,t,i,o,s,r){const a=[],d=e.TWO_PI/t;let h=0;for(let l=0;l<t;l++){const t=s*e.cos(h)+i/2,c=s*e.sin(h)+o/2,u=new n.Vertex(l,t,c);u.displayValue=r,a.push(u),h+=d}return a}function s(e,t){for(const i of t)if(e.dist(e.mouseX,e.mouseY,i.x,i.y)<20)return i}},14:(e,t,i)=>{"use strict";i.r(t),i.d(t,{GrowingEdge:()=>o});var n=i(964);function o(e,t){this.weight=1,this.increaseWeight=function(){this.weight+=1/p.deltaTime,this.weight=this.weight%10},this.display=function(i){i.push(),i.stroke(n.GREY.r,n.GREY.g,n.GREY.b),i.strokeWeight(this.weight),i.line(e,t,i.mouseX,i.mouseY),i.pop()}}},745:(e,t,i)=>{"use strict";i.r(t),i.d(t,{Vertex:()=>s});var n=i(964),o=i(878);function s(e,t,i){this.id=e,this.x=t,this.y=i,this.edges=[],this.value,this.displayValue;let s=n.GREY.r,r=n.GREY.g,a=n.GREY.b,d=0,h=new Set;this.display=function(e,t){if(void 0===this.x||void 0===this.y)return;e.push(),e.stroke(s,r,a,80),e.strokeWeight(d),e.fill(s,r,a),e.circle(this.x,this.y,t),e.fill(0,0,0),e.strokeWeight(0);let i=this.displayValue.length>0?" : "+this.displayValue:"";e.textAlign(e.CENTER),e.text(this.id+i,this.x,this.y+t),e.pop()},this.displayEdges=function(e,t){for(const i of this.edges)i.display(e,t,!0)},this.changeColor=function(e){s=e.r,r=e.g,a=e.b},this.getColor=function(){return{r:s,g:r,b:a}},this.changeStrokeWeight=function(e){d=e},this.addEdge=function(e,t){e.id==this.id||h.has(e.id)||(h.add(e.id),this.edges.push(new o.Edge(t,this,e)))}}},581:(e,t,i)=>{"use strict";i.r(t),i.d(t,{sketch:()=>a,explainText:()=>d});var n=i(964),o=i(401),s=i(14),r=i(175);function a(e){let t,i,a,d,h=[],l=0;e.setup=function(){e.createCanvas(550,550),a=e.createButton(""),a.position(10,40),a.addClass("action-button"),h=(0,o.drawVertices)(e,20,550,550,200,"?")},e.draw=function(){e.background(255,255,255),function(){switch(l){case 0:e.text("Click on nodes to add link.\nOnce the graph is done, click on the button to find strongly connected components (SCC)",10,10),a.html("Find SCC"),a.show(),a.mousePressed((function(){l=1,d=(0,r.tarjan)(h,50)}));break;case 1:e.text("Finding strongly connected components",10,10),a.hide();break;case 2:e.text("Strongly connected components found",10,10),a.show(),a.html("Restart"),a.mousePressed((function(){h=[],d=void 0,l=0,h=(0,o.drawVertices)(e,20,550,550,200,"?")}))}}(),e.push(),e.strokeWeight(0),e.fill(n.GREY.r,n.GREY.g,n.GREY.b),e.circle(30,520,30),e.textAlign(e.LEFT),e.fill(0,0,0),e.text("ID : group",60,520),e.pop(),0==l?void 0!==t&&t.display(e):1==l&&d.next().done&&(l=2);for(const t of h)t.displayEdges(e,30);for(const t of h)t.display(e,30)},e.mouseReleased=function(){if(l>0)return;const n=(0,o.getClosestVertex)(e,h);void 0!==n&&(void 0===i?(i=n,t=new s.GrowingEdge(i.x,i.y)):(i.addEdge(n,1),i=void 0,t=void 0))}}const d="<p><strong>Tarjan's algorithm</strong> finds strongly connected components in a graph. A strongly connected component is a group of nodes in which every node is reachable by any other node.</p><p>The algorithm starts at a random node and uses depth first search to visit all its neighbors and their neighbors. When visiting a node, a low link value is assigned to the node which represents the lowest node reachable from the current node. Low link value is initialized to 0 and increment each time it's assigned to a node.</p><p>When meeting a node already visited during current depth first search, the algorithm backtracks and update the low link value to the lower value between the already visited node and the currently visiting node.</p><p>After visiting all the reachable nodes from the current depth first search start point, the algorithm picks the next random unvisited node and repeat the procedure. Note that low link value should only be updated when meeting node visited during current depth first search, not the previously visited ones.</p><p>Nodes with the same low link value belong to one strongly connected component.</p>"},175:(e,t,i)=>{"use strict";i.r(t),i.d(t,{tarjan:()=>a});var n=i(964),o=i(252),s=i(129),r=i(878);function*a(e,t){let i=(0,s.waitNFrame)(t);const a=new Array(e.length),d=new Array(e.length),h=new o.Stack,l=new o.Stack;let c=0;for(const t of e){if(2===a[t.id])continue;let e=c,o=0;for(h.push({seq:o,edge:new r.Edge(0,null,t)}),l.push({seq:o,edge:new r.Edge(0,null,t)}),o++;h.size()>0;){let t=h.pop().edge,s=t.to;a[s.id]=1,s.value=c,d[s.id]=c,s.displayValue="group "+c++;const r={r:Math.floor(256*Math.random()),g:Math.floor(256*Math.random()),b:Math.floor(256*Math.random())};for(t.changeColor(n.RED),s.changeColor(r);!1===i.next().value;)yield;for(const t of s.edges){let s=t.to;if(void 0===a[s.id])h.push({seq:o,edge:t}),l.push({seq:o,edge:t}),o++;else if(s.value>=e){for(t.changeColor(n.RED);!1===i.next().value;)yield;for(t.changeColor(n.GREY);l.size()>0&&(0===h.size()||l.peek().seq!==h.peek().seq);){let e=l.pop().edge,t=e.to;for(a[t.id]=2,s.value<t.value&&(t.value=s.value,t.displayValue=s.displayValue,d[t.id]=d[s.id],t.changeColor(s.getColor())),e.changeColor(n.GREY);!1===i.next().value;)yield}}}for(;l.size()>0&&(0===h.size()||l.peek().seq!==h.peek().seq);){let e=l.pop().edge,t=e.to;for(e.changeColor(n.GREY),a[t.id]=2;!1===i.next().value;)yield}}}return d}},964:(e,t,i)=>{"use strict";i.r(t),i.d(t,{RED:()=>n,BLUE:()=>o,GREY:()=>s});const n={r:254,g:144,b:160},o={r:89,g:235,b:199},s={r:154,g:167,b:160}},726:(e,t,i)=>{"use strict";function n(){let e,t,i=0;this.addFirst=function(t){let n={value:t};n.next=e,e=n,i++},this.add=function(n){let o={value:n};null==e&&(e=o),null==t?t=o:(t.next=o,t=t.next),i++},this.peek=function(){return null!=e?e.value:void 0},this.poll=function(){const t=e;return e=e.next,i--,t.value},this.size=function(){return i}}i.r(t),i.d(t,{LinkedList:()=>n})},252:(e,t,i)=>{"use strict";i.r(t),i.d(t,{Stack:()=>o});var n=i(726);function o(){let e=new n.LinkedList;this.push=function(t){e.addFirst(t)},this.pop=function(){return e.poll()},this.peek=function(){return e.peek()},this.size=function(){return e.size()}}},129:(e,t,i)=>{"use strict";function*n(e){for(;;){for(let t=0;t<e-1;t++)yield!1;yield!0}}i.r(t),i.d(t,{waitNFrame:()=>n})}}]);